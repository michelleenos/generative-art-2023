var M=Object.defineProperty;var b=(r,s,t)=>s in r?M(r,s,{enumerable:!0,configurable:!0,writable:!0,value:t}):r[s]=t;var h=(r,s,t)=>(b(r,typeof s!="symbol"?s+"":s,t),t);import{m as y}from"./utils-410b772c.js";function f(r,s){let t=R(r,s);return{num:r/t,denom:s/t}}function R(r,s){let t=Math.min(r,s);for(;t>0&&!(r%t===0&&s%t===0);)t--;return t}class m{constructor(s){h(this,"radius");h(this,"y");h(this,"lineLen");h(this,"points",[]);h(this,"steps",[]);h(this,"step",0);h(this,"stepsPerSec",60);h(this,"progress",0);h(this,"draw",s=>{this.drawBase(s);let t=this.steps[this.current],e=this.points[this.current];if(t){s.circle(t.x,t.y,this.radius*2),e&&(s.line(t.x,t.y,e.x,e.y),s.fill(255),s.circle(e.x,e.y,5)),s.noFill(),s.beginShape();for(let i=0;i<=this.current;i++){let a=this.points[i];a&&s.vertex(a.x,a.y)}s.endShape()}});this.radius=s.radius,this.y=s.y??0,this.lineLen=s.lineLen??this.radius}get circumference(){return 2*Math.PI*this.radius}get current(){let s=this.steps.length*2-2,t=Math.floor(this.step)%s;return t>this.steps.length-1&&(t=s-t),t}tick(s){this.step=this.step+s*.06}}class L extends m{constructor({radius:t,y:e=0,lineLen:i=t,width:a}){super({radius:t,y:e,lineLen:i});h(this,"width");h(this,"drawBase",t=>{t.push(),t.strokeWeight(.5),t.line(-t.width/2,this.y+this.radius,t.width/2,this.y+this.radius),t.pop()});this.width=a,this.makeSteps()}get stepSize(){return this.radius*.005}makeSteps(){this.steps=[],this.points=[];let t=-this.width/2,e=Math.PI*.5,i=this.stepSize/(Math.PI*2),a=this.circumference*i;for(;t<=this.width/2+this.radius;){e+=this.stepSize,t+=a;let l=Math.cos(e)*this.lineLen+t,n=Math.sin(e)*this.lineLen+this.y;this.steps.push({rotation:e,x:t,y:this.y}),this.points.push({x:l,y:n})}}}function g(r){return"ratio"in r}class P extends m{constructor(t){let e,i,a;g(t)?(e=t.radius??30,i=e*t.ratio,a=t.ratio):(e=t.radius,i=t.baseRadius);let l=t.y??0,n=t.cx??0,c=t.lineLen??e;super({radius:e,y:l,lineLen:c});h(this,"_baseRadius");h(this,"cx");h(this,"ratio");h(this,"drawBase",t=>{t.push(),t.strokeWeight(.5),t.noFill(),t.circle(this.cx,this.y,this.baseRadius*2),t.pop()});a&&(this.ratio=a),this._baseRadius=i,this.cx=n,this.makeSteps()}get baseRadius(){return this.ratio?this.radius*this.ratio:this._baseRadius}set baseRadius(t){this._baseRadius=t}get circumferenceBase(){return 2*Math.PI*this.baseRadius}makeSteps(){this.steps=[],this.points=[];let t=0,e=this.circumferenceBase,i=0,{denom:a}=f(this.radius,this.baseRadius),l=Math.ceil(Math.PI*2*a),n=Math.min(y(a,1,60,this.radius*.1,this.radius*.3),this.radius*.3),c=n/this.circumference*Math.PI*2;for(;i<=l;){t+=n;let u=t/e*Math.PI*2;i+=c;let d=Math.cos(u)*(this.radius+this.baseRadius),o=Math.sin(u)*(this.radius+this.baseRadius),p=d-Math.cos(u+i)*this.lineLen,x=o-Math.sin(u+i)*this.lineLen;this.points.push({x:p,y:x}),this.steps.push({rotation:i,x:d,y:o})}}}class B extends m{constructor(t){let e=t.radius,i=t.baseRadius??e,a=t.y??0,l=t.cx??0,n=t.lineLen??e;super({radius:e,y:a,lineLen:n});h(this,"baseRadius");h(this,"cx");h(this,"drawBase",t=>{t.push(),t.strokeWeight(.5),t.noFill(),t.circle(this.cx,this.y,this.baseRadius*2),t.pop()});this.baseRadius=i,this.cx=l,this.makeSteps()}get circumferenceBase(){return 2*Math.PI*this.baseRadius}makeSteps(){this.steps=[],this.points=[];let t=0,e=this.circumferenceBase,i=0,{denom:a}=f(this.radius,this.baseRadius),l=Math.ceil(Math.PI*2*a),n=Math.min(y(a,1,60,this.radius*.1,this.radius*.3),this.radius*.3),c=n/this.circumference*Math.PI*2;for(;i>=l*-1;){t+=n;let u=t/e*Math.PI*2;i-=c;let d=Math.cos(u)*(this.baseRadius-this.radius),o=Math.sin(u)*(this.baseRadius-this.radius),p=d+Math.cos(u+i)*this.lineLen,x=o+Math.sin(u+i)*this.lineLen;this.points.push({x:p,y:x}),this.steps.push({rotation:i,x:d,y:o})}}}export{P as E,B as H,L as T};
