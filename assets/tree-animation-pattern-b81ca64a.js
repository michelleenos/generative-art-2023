var y=Object.defineProperty;var b=(e,i,t)=>i in e?y(e,i,{enumerable:!0,configurable:!0,writable:!0,value:t}):e[i]=t;var g=(e,i,t)=>(b(e,typeof i!="symbol"?i+"":i,t),t);import{e as u}from"./shapes-52b2702a.js";import{T as P}from"./tree-animation-7ab59557.js";import{r as S}from"./utils-410b772c.js";const O=(e,{bounds:i,c1:t,c2:l,progress:s=1})=>{let{x:o,y:h,width:n,height:a}=i,r=Math.min(n,a),d=Math.max((r-8)*.5,0),p=Math.max(d*s,0),m=Math.max(d/3*2*s,0),M=Math.max(d/3*1*s,0);e.save(),e.fillStyle=t,e.beginPath(),e.arc(o+r/2,h+r/2,p,0,Math.PI*2),e.fill(),e.fillStyle=l,e.beginPath(),e.arc(o+r/2,h+r/2,m,0,Math.PI*2),e.fill(),e.fillStyle=t,e.beginPath(),e.arc(o+r/2,h+r/2,M,0,Math.PI*2),e.fill(),e.restore()},I=(e,{bounds:i,c1:t,progress:l=1})=>{let{x:s,y:o,width:h,height:n}=i,a=Math.min(h,n),r=Math.max((a-8)*.5*l,0);e.save(),e.translate(s+(h-a)/2,o+(n-a)/2),e.fillStyle=t,e.beginPath(),e.arc(a/2,a/2,r,0,Math.PI*2),e.fill(),e.restore()},R=(e,{bounds:i,c1:t,progress:l=1})=>{let{x:s,y:o,width:h,height:n}=i,a=Math.min(h,n);a-=Math.max(a*.1,10),e.save(),e.translate(s,o),u(e,{x:(h-a)/2,y:(n-a)/2,w:a,h:a,progress:l}),e.fillStyle=t,e.strokeStyle=t,e.lineWidth=Math.min(5,a*l/2),e.stroke(),a<30&&e.fill(),e.restore()},q=(e,{bounds:i,c1:t,c2:l,progress:s=1})=>{let{x:o,y:h,width:n,height:a}=i,r=4,d=Math.max(n-r*2,0),p=4,m=Math.max(a*.5-r-p/2,4);m*=s;let M=o+(n-d)/2,f=Math.min(d/4,m/4);e.save(),e.fillStyle=t,e.beginPath(),e.roundRect(M,h+a/2-p/2-m,d,m,[f,f,0,0]),e.fill(),e.fillStyle=l,e.beginPath(),e.roundRect(M,h+a/2+p/2,d,m,[0,0,f,f]),e.fill(),e.restore()},V=(e,{bounds:i,c1:t,c2:l,progress:s=1})=>{let{x:o,y:h,width:n,height:a}=i,r=4,d=Math.max(a-r*2,0),p=4,m=Math.max(n*.5-r-p/2,4);m*=s;let M=h+(a-d)/2,f=Math.min(m/4,d/4);e.save(),e.fillStyle=t,e.beginPath(),e.roundRect(o+n/2-p/2-m,M,m,d,[f,0,0,f]),e.fill(),e.fillStyle=l,e.beginPath(),e.roundRect(o+n/2+p/2,M,m,d,[0,f,f,0]),e.fill(),e.restore()};class D extends P{constructor(t){super(t);g(this,"patterns");g(this,"palette");g(this,"noiseOptsPattern");g(this,"getLeafData",t=>{let l=this.getNoise(t),s=l*.5+.5;s+=S(.8)+t.depth;let o=Math.floor(s)%this.palette.length,h=(o+1)%this.palette.length,n=l*.5+.5,a=Object.keys(this.patterns),r=a[Math.floor(a.length*n)],d=this.patterns[r];return{color1:this.palette[o],color2:this.palette[h],pattern:d}});g(this,"draw",t=>{t.save(),this.leaves.forEach(l=>{let s=l.progress;l.data||(l.data=this.getLeafData(l)),l.data.pattern(t,{bounds:l.bounds,c1:l.data.color1,c2:l.data.color2,progress:s})})});this.noiseOptsPattern={key:"pattern",freq:.64,speed:1.6,...t.noiseOptsPattern},this.palette=t.palette,this.patterns=t.patterns}}export{D as T,I as a,q as b,O as c,V as d,R as e};
