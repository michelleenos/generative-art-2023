var y=Object.defineProperty;var _=(o,t,e)=>t in o?y(o,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):o[t]=e;var s=(o,t,e)=>(_(o,typeof t!="symbol"?t+"":t,e),e);import{a as D}from"./simplex-noise-c4e77999.js";import{a as L,m as b,r as v,d as f}from"./utils-410b772c.js";import{e as u}from"./easings-ac43f515.js";import{N as w}from"./node-40679d3e.js";class g{constructor({duration:t,easing:e,dir:i}={}){s(this,"delta",0);s(this,"easing","linear");s(this,"progress",0);s(this,"linearProgress",0);s(this,"duration",1e3);s(this,"dir",1);s(this,"resolver");s(this,"promise");this.duration=t||this.duration,this.easing=e||this.easing,this.dir=i||this.dir,this.getPromise()}tick(t){this.delta=t,this.dir===1?this.linearProgress=Math.min(1,this.linearProgress+this.delta/this.duration):this.linearProgress=Math.max(0,this.linearProgress-this.delta/this.duration),this.progress=u[this.easing](this.linearProgress),this.round(),(this.linearProgress>=1||this.linearProgress<=0)&&this.resolve()}resolve(){this.resolver()}round(){this.progress=L(this.progress,5)}reverse(t){return this.dir=-1,t!==void 0&&(this.linearProgress=t),this.getPromise()}restart(){return this.linearProgress=0,this.progress=0,this.dir=1,this.getPromise()}reset(){return this.restart()}complete(){this.linearProgress=1,this.progress=1,this.resolve()}setProgress(t){this.linearProgress=t,this.progress=u[this.easing](this.linearProgress)}getPromise(){let t,e=new Promise(i=>{t=i});return this.promise=e,this.resolver=t,e}}class m extends w{constructor(e,{depth:i=0,parent:r=null,duration:h=500,divideRule:a,easeEnter:n="inOutQuad",easeLeave:l="inOutQuad",delayAnimate:d=0,delayFn:p}={}){super(e,{depth:i,divideRule:a});s(this,"children",[]);s(this,"parent");s(this,"points",[]);s(this,"state","entering");s(this,"birthday",Date.now());s(this,"_duration");s(this,"timer");s(this,"_easeLeave","inOutQuad");s(this,"_easeEnter","inOutQuad");s(this,"delayAnimate",0);s(this,"delayFn");s(this,"data");if(this.parent=r,this._duration=h,this._easeEnter=n,this._easeLeave=l,d>0){let c=this._duration*d,E=this._duration+c;this.delayAnimate=d,this.timer=new g({duration:E,easing:"linear"})}else this.timer=new g({duration:this._duration,easing:"linear"});p&&(this.delayFn=p)}get duration(){return this._duration}set duration(e){this._duration=e,this.timer.duration=e}get progress(){if(this.state==="idle")return 1;if(this.state==="entering")return u[this.easeEnter](this.timer.progress);if(this.state==="parentWillCollapse"&&this.delayAnimate>0){let e=this.timer.progress;return e<this.delayAnimate?1:u[this._easeLeave](b(e,this.delayAnimate,1,1,0))}return u[this.easeLeave](1-this.timer.progress)}get age(){return Date.now()-this.birthday}get easeLeave(){return this._easeLeave}get easeEnter(){return this._easeEnter}set easeLeave(e){this._easeLeave=e}set easeEnter(e){this._easeEnter=e}beIdle(){this.state="idle",this.timer.complete()}tick(e){this.timer.tick(e),this.state==="entering"&&this.timer.progress===1?this.state="idle":this.state==="willDivide"&&this.timer.progress===1?this.divide():this.state==="willCollapse"&&this.timer.progress===1&&this.collapse()}divide(){let e=this.divideRect();return e?(this.children=e.map((i,r)=>new m(i,{depth:this.depth+1,parent:this,duration:this._duration,divideRule:this.divideRule,delayAnimate:this.delayFn?this.delayFn(r,e.length):0,delayFn:this.delayFn})),this.beIdle(),!0):!1}collapse(){let e=super.collapse();return e&&(this.state="entering",this.timer.restart(),this.birthday=Date.now()),e}isBusy(){return this.state!=="idle"}setWillDivide(){return this.isBusy()||this.children.length>0?!1:(this.state="willDivide",this.timer.restart())}setWillCollapse(e){if(this.isBusy())return!1;if(this.children.length===0)if(e&&e>0){let a=e*this._duration;return this.state="parentWillCollapse",this.timer=new g({duration:a+this._duration}),this.delayAnimate=a/(this._duration+a),this.timer.promise}else return this.timer=new g({duration:this._duration}),this.state="parentWillCollapse",this.delayAnimate=0,this.timer.promise;let i=this.getLeaves();if(!!i.some(a=>a.state!=="idle"))return!1;let h=[];for(let a=0;a<i.length;a++){let l=i[a].setWillCollapse(this.delayFn?this.delayFn(a,i.length):0);if(!l)return!1;h.push(l)}return this.state="willCollapse",Promise.all(h).then(()=>{this.collapse()})}}class F{constructor({bounds:t,...e}){s(this,"node");s(this,"bounds");s(this,"lastTime",0);s(this,"leaves",[]);s(this,"noise",D());s(this,"thresholdChange",.8);s(this,"divideRule","quarters-grid");s(this,"_nodeDuration",800);s(this,"_nodeEaseEnter","inCubic");s(this,"_nodeEaseLeave","outCubic");s(this,"noiseVals",{});s(this,"noiseOptions");s(this,"maxDepth",5);s(this,"minDepth",3);s(this,"minLifeSpan",1800);s(this,"initTree",()=>{this.node.clear(),this.node.divideRule=this.divideRule;let t=this.bounds,e=v(t.x,t.x+t.width),i=v(t.y,t.y+t.height),r=this.node.getLeaves(),h=Math.min(...r.map(a=>a.depth));for(;h<this.minDepth;){let a=f(t.x,t.x+t.width,e),n=f(t.y,t.y+t.height,i),l=this.node.findNode(a,n);l&&l.depth<this.maxDepth&&l.divide(),r=this.node.getLeaves(),h=Math.min(...r.map(d=>d.depth))}this.refreshLeaves()});s(this,"divide",t=>{let e=t.setWillDivide();return e?(e.then(()=>{this.refreshLeaves()}),!0):!1});s(this,"collapse",t=>{let e=t.parent,i=e==null?void 0:e.setWillCollapse();return i?(i.then(()=>{this.refreshLeaves()}),!0):!1});s(this,"draw",t=>{t.save(),this.leaves.forEach(e=>{let i=e.progress;t.fillStyle=`rgba(0, 0, 0, ${i})`,t.fillRect(e.bounds.x,e.bounds.y,e.bounds.width,e.bounds.height)}),t.restore()});s(this,"refreshLeaves",()=>{this.leaves=this.node.getLeaves()});this.bounds=t,this.noiseOptions={key:"default",freq:.64,speed:1.2,...e.noiseOptions||{}},e.nodeDuration&&(this._nodeDuration=e.nodeDuration),e.nodeEaseEnter&&(this._nodeEaseEnter=e.nodeEaseEnter),e.nodeEaseLeave&&(this._nodeEaseLeave=e.nodeEaseLeave),e.divideRule&&(this.divideRule=e.divideRule),e.maxDepth&&(this.maxDepth=e.maxDepth),e.minDepth&&(this.minDepth=e.minDepth),e.thresholdChange&&(this.thresholdChange=e.thresholdChange),e.minLifeSpan&&(this.minLifeSpan=e.minLifeSpan),this.node=new m(t,{duration:this._nodeDuration,delayFn:e.delayFn})}set nodeDuration(t){this._nodeDuration=t,this.node.getAll().forEach(e=>e.duration=t)}get nodeDuration(){return this._nodeDuration}get nodeEaseLeave(){return this._nodeEaseLeave}get nodeEaseEnter(){return this._nodeEaseEnter}set nodeEaseEnter(t){this._nodeEaseEnter=t,this.node.getAll().forEach(e=>e.easeEnter=t)}set nodeEaseLeave(t){this._nodeEaseLeave=t,this.node.getAll().forEach(e=>e.easeLeave=t)}tick(t,e){let i=t-this.lastTime;this.lastTime=t,this.draw(e),this.noiseVals={},this.leaves.forEach(r=>{var n;if(r.isBusy()||(n=r.parent)!=null&&n.isBusy()||r.age<this.minLifeSpan){r.tick(i);return}let h=this.getNoise(r,this.noiseOptions),a=this.thresholdChange;h>a&&r.depth<this.maxDepth?this.divide(r):h<-a&&r.depth>this.minDepth&&this.collapse(r),r.tick(i)})}getNoise(t,e=this.noiseOptions){let i=Math.round(t.bounds.x+t.bounds.width/2),r=Math.round(t.bounds.y+t.bounds.height/2),h=`${e.key}-${i}-${r}`;return h in this.noiseVals||(this.noiseVals[h]=this.calculateNoise(i,r,e)),this.noiseVals[h]}calculateNoise(t,e,{freq:i,speed:r}){let h=(typeof i=="number"?i:i.x)*.001,a=(typeof i=="number"?i:i.y)*.001,n=r*.001;return this.noise(t*h,e*a,this.lastTime*n)}}export{F as T};
